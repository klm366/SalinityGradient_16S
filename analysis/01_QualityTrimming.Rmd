---
title: "Quality Control: Filtering & Trimming Amplicon Sequences"
author: "Mar Schmidt"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  html_document: 
    code_folding: show
    theme: spacelab
    highlight: pygments
    keep_md: no
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: yes
      toc_depth: 3
  keep_md: true  
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      fig.align = "center",
                      fig.path = "../figures/01_DADA2/") # send any figure output to this folder 
```


# Setting up the environment

### Set the seed 

**Why Set a Seed?**

1. *Reproducibility*:
    - If you’re using random number generation (e.g., bootstrapping, simulations, machine learning models), setting a seed ensures that you (and others) can get the same results every time you run the code.
2. *Debugging & Collaboration*:
    - If your analysis involves randomness (e.g., shuffling datasets, training ML models), setting a seed makes it easier to debug and compare results across different runs or machines.
    - Colleagues can run your code and get identical results, making scientific collaboration more reliable.
3. *Benchmarking & Model Comparisons*:
    - In machine learning, setting a seed ensures that models trained with random splits of data or initial weights are comparable across different trials.
    - If you don’t set a seed, each run might give slightly different performance metrics, making it harder to evaluate true differences between models.
4. *Avoiding Accidental Bias in Random Sampling*:
    - When selecting random subsets of data (e.g., cross-validation splits), setting a seed ensures that all experiments are based on the same random selection, reducing unwanted variability.

```{r set-seed}
# Any number can be chosen 
set.seed(238428)
```

### Timing of Script
```{r rmd-start}
# What time did we start running this script? 
start_time <- Sys.time()
start_time
```


# Goals of this file 

**NOTE:** This document was **NOT** run during class. Instead, it is building off of what we covered in class to help move the learning along for lab next week. We will start at the error modeling step in lab next week.

1. Use raw fastq files and generate quality plots to assess quality of reads.
2. Filter and trim out bad sequences and bases from our sequencing files. 
3. Write out fastq files with high quality sequences. 
4. Evaluate the quality from our filter and trim. 
5. Infer Errors on forward and reverse reads individually.
6. Identified ASVs on forward and reverse reads separately, using the error model.  
7. Merge forward and reverse ASVs into "contiguous ASVs".  
8. Generate the ASV count table. (`otu_table` input for phyloseq.). 


Output that we will create in this file: 

1. Quality plots to asses pre- and post-quality trimming. 
2. Written files that include the filtered and trimmed data. 


# Load Libraries 
```{r load-libraries}
# Efficient package loading with pacman 
# Don't forget to install pacman and DT if you don't have it yet. :) 
pacman::p_load(tidyverse, dada2, phyloseq, patchwork, DT, devtools, install = FALSE)
```


# Reading Raw Sequencing Files 
```{r load-data}
# Set the raw fastq path to the raw sequencing files 
# Path to the fastq files 
raw_fastqs_path <- "data/01_DADA2/01_raw_gzipped_fastqs"
raw_fastqs_path

# What files are in this path? Intuition Check 
head(list.files(raw_fastqs_path))

# How many files are there? 
list(list.files(raw_fastqs_path))

# Create vector of forward reads
forward_reads <- list.files(raw_fastqs_path, pattern = "R1_001.fastq.gz", full.names = TRUE)  

# Intuition Checks 
head(forward_reads)
# Intuition check #2: We should have fewer reads in the forward vector than in total 
stopifnot(length(forward_reads) < length(list.files(raw_fastqs_path)))

# Create a vector of reverse reads 
reverse_reads <- list.files(raw_fastqs_path, pattern = "R2_001.fastq.gz", full.names = TRUE)

# Intuition Checks
head(reverse_reads)
# Intuition check #2: Need to have equal number of forward and reverse files 
stopifnot(length(reverse_reads) == length(forward_reads))
```

# Assess Raw Read Quality 

## Evaluate raw sequence quality 

Let's see the quality of the raw reads *before* we trim

### Plot 12 random samples of plots 
```{r raw-quality-plot, fig.width=12, fig.height=8}
# Randomly select 12 samples from dataset to evaluate 
# Selecting 12 is typically better than 2 (like we did in class for efficiency)
random_samples <- sample(1:length(reverse_reads), size = 12)
random_samples

# Calculate and plot quality of these two samples
forward_filteredQual_plot_12 <- plotQualityProfile(forward_reads[random_samples]) + 
  labs(title = "Forward Read: Raw Quality")

reverse_filteredQual_plot_12 <- plotQualityProfile(reverse_reads[random_samples]) + 
  labs(title = "Reverse Read: Raw Quality")


# Plot them together with patchwork
forward_filteredQual_plot_12 + reverse_filteredQual_plot_12
```

**REMEMBER:** If you have NextSeq data, your quality scores will be binned, instead of having the 40 integer phred scores. This is ok!

Note that the quality score represents the Phred Score, which is described below: 

| **Q Score** | **Error Probability** | **Confidence Level**            |
|------------|---------------------|--------------------------------|
| **40**     | 0.0001 (1 in 10,000) | **Very high-quality base**    |
| **30**     | 0.001 (1 in 1,000)   | **High-quality base** (gold standard) |
| **20**     | 0.01 (1 in 100)      | **Acceptable but lower confidence** |
| **10**     | 0.1 (1 in 10)        | **Poor-quality base**         |
| **<10**    | >0.1 (high error rate) | **Unreliable base call**       |

# **Acceptable Phred Scores for ASVs with DADA2**

In **DADA2** (a widely used tool for **denoising amplicon sequencing data** and generating **ASVs**), **quality filtering is crucial** for obtaining reliable biological sequences. Below are the acceptable **Phred score** thresholds for DADA2 preprocessing:

## **Recommended Quality Thresholds for DADA2**

| **Q Score**   | **Error Probability**    | **DADA2 Interpretation**            |
|--------------|------------------------|------------------------------------|
| 40        | 0.0001 (1 in 10,000) | Very high-quality , dream come true   | 
| ≥ 30     | ≤ 0.001 (1 in 1,000) | Excellent quality, keep                |
| 25 - 30 | ~0.003 - 0.01        | Can be acceptable, but more important to trim low-quality tails |
| 20 - 25 | ~0.01 - 0.03         | Lower quality, only acceptable if read length is absolutely critical |
| < 20    | > 0.01 (1 in 100)    | Poor quality, remove                    |
| <10     | >0.1 (1 in 10)       | Very unreliable, absolutely remove      |
---

Some summary take-aways:

✔ **30 is good** – Bases with Q30+ scores have a **99.9% accuracy rate**, making them highly reliable.  
✔ **25-30 can be acceptable**, but trimming is preferred to remove low-quality tails.  
✔ **20-25** should only be kept if read length is absolutely critical (*e.g.* to ensure forward & reverse read overlap)
✔ **<20 discarded** – Bases with Phred scores below 20 have an **error rate >1%** and should 100% be **trimmed from the dataset**.  

Remember, every base counts when we assign ASVs, they are called **sequence variants** for a reason! And, we want to be sure. :)

---
### Aggregated Raw Quality Plots 
```{r raw-aggregate-plot, fig.width=5.5, fig.height=3.5}
# Aggregate all QC plots 
# Forward reads
forward_preQC_plot <- 
  plotQualityProfile(forward_reads, aggregate = TRUE) + 
  labs(title = "Forward Pre-QC")

# reverse reads
reverse_preQC_plot <- 
  plotQualityProfile(reverse_reads, aggregate = TRUE) + 
  labs(title = "Reverse Pre-QC")

preQC_aggregate_plot <- 
  # Plot the forward and reverse together 
  forward_preQC_plot + reverse_preQC_plot

# Show the plot
preQC_aggregate_plot
```


<span style="color: red;">Here, in this location of your analyses, please insert a description of the interpretation you draw regarding your plots. You must note anything important about the figure you've created about your data including any spikes in quality and also the general trend of the raw QC plots. An example is provided below.</span> 

Above are plots showing the pre-QC quality scores of the raw sequencing data for the project. We can draw a few conclusions from the plots above, which were generated with 2x250 bp sequencing on an Illumina MiSeq Sequencer: 

1.	*Early Bases have a drop in quality (~Cycle/Bases 0-10):* 
    - Both forward and reverse reads show a steep quality drop in the first ~10 bases, but this is mostly above 30, which is acceptable.
        - Notably, the first few bases at the beginning of the forward reads have a VERY LOW and unacceptable quality score, which we also noticed during our run of fastQC and multiQC. These bases therefore need to be removed!
    - **Solution**: Trim forward read 5 low-quality bases using the `trimLeft` parameter.
2.	*High Quality in Mid-Read (~3-250 Cycles/Bases):* 
    - Quality is stable and above Q30 across most of the sequencing cycle/read.
    - This suggests that most of the read length is high-quality and can be retained.
3.	*Decline in Reverse Reads After ~200 Cycles/Bases:*
    - The reverse reads degrade more quickly than the forward reads, more on this below.
    - The last ~ 2 bases of the reverse reads shows a drop below 30, indicating a high sequencing error rates.
        - However, this was not seen in fastQC and multiQC. So, we will keep the full read.
    - **Solution**: We will truncate the read using ` truncLen = 248` to remove those final 2 poor-quality bases at the end of the read. The beginning of the read is ~35 so we are ok at the beginning of the read.
4.	*Forward Reads Maintain Quality Slightly Longer*
    - Forward reads degrade after ~220-230 cycles, but the quality drop is less severe than in reverse reads. However, these Phred scores are still acceptable.
    - **Solution**: Beyond `trimLeft=3`, no other truncation of the forward reads is necessary.

**General notes on Illumina sequencing**

- **Forward & Reverse Reads:** 
  - Typically all reads decline in quality over the sequencing run due to phasing (*i.e.* when the clusters become out of sync with each other later in the run). 
  - Read quality at the beginning of the read can be common due to primer/adapter sequence artifacts
- **Reverse Reads Quality is generally lower because:** 
  - Sequencing of the reverse reads happens second, after chemistry degrades a bit after sequencing the forward reads. 
  - Physical flipping of the sequence is required.
  - Phasing errors are enhanced, more accumulated errors.
  - Optical strength is weaker compared to the first sequencing, leading to more miscalls. 

## Prepare a placeholder for filtered reads 
```{r prep-filtered-sequences}
# vector of our samples, extract sample name from files 
samples <- sapply(strsplit(basename(forward_reads), "_"), `[`,1) 
# Intuition Check 
head(samples)

# Place filtered reads into filtered_fastqs_path
filtered_fastqs_path <- "data/01_DADA2/02_filtered_fastqs"
filtered_fastqs_path

# create 2 variables: filtered_F, filtered_R
filtered_forward_reads <- 
  file.path(filtered_fastqs_path, paste0(samples, "_R1_filtered.fastq.gz"))
length(filtered_forward_reads)

# reverse reads
filtered_reverse_reads <- 
  file.path(filtered_fastqs_path, paste0(samples, "_R2_filtered.fastq.gz"))
head(filtered_reverse_reads)
```

# Filter and Trim Reads

Parameters of filter and trim **DEPEND ON THE DATASET AND SEQUENCING RUN**. If your sequences are run on multiple sequencing runs, you will need to run these separately!!! I recommended making parallel processes (either in separate files or back-to-back in a single file for each sequencing run). 

Some things to keep in mind are:

- The library preparation: *Are the primers included in the sequence? If so, they need to be trimmed out in this step*.  
- What do the above quality profiles of the reads look like? *If they are lower quality, it is highly recommended to use `maxEE = c(1,1)`.*  
- Do the reads dip suddenly in their quality? If so, explore `trimLeft` and `truncLen`
- Check out more of the parameters using `?filterAndTrim` to bring up the help page and do some googling about it. Some notes on two examples are below, with a description of a few of the parameters:

1. **In class dataset**: This salinity gradient dataset was generated with the library preparation described by [Kozich et al., 2013 AEM](https://doi.org/10.1128/AEM.01043-13), the reads maintained high Phred Scores (above 30, even more typically above ~34) all the way through to the end of the sequence. Therefore, we will not truncate the data for this dataset and we will use a less stringent `maxEE = c(2,2)`.  
2. **Lower quality datasets** However, if the sequence quality was lower, it's recommended to use `maxEE = c(1,1)` as is in the commented out example below. In the other example (not executed but the code is shown) the dataset had the primers in their sequence (as they were prepared using the Illumina 2-step PCR protocol and therefore include the primer in the sequence. In addition with trimming the My reverse reads are of much lower quality, which is typical, so I truncated these at a lower value, where the Phred Scores drop below about 30. The values of these parameters are going to be highly specific to your own analysis, but you can also play it safe and go with the default values listed on the official DADA2 pipeline.

Important parameters to be aware of

- `maxEE` is a quality filtering threshold applied to expected errors. Here, if there's 2 expected errors. It's ok. But more than 2. Throw away the sequence. Two values, first is for forward reads; second is for reverse reads. If your read quality is generally lower than this dataset, I recommended you use `maxEE = c(1,1)`.  
- `trimLeft` can be used to remove the beginning bases of a read (e.g. to trim out primers!) 
- `truncLen` can be used to trim your sequences after a specific base pair when the quality gets lower. Though, please note that **this will shorten the ASVs**! For example, this can be used when the quality of the sequence suddenly gets lower, or clearly is typically lower. So, if the quality of the read drops below a phred score of 25 (on the y-axis of the plotQualityProfile above, which indicates ~99.5% confidence per base).  
- `maxN` the number of N bases. Here, using ASVs, we should ALWAYS remove all Ns from the data.  

```{r filter-and-trim}
# Assign a vector to filtered reads 
# trim out poor bases, first 3 bps on F reads
# write out filtered fastq files 
# Here, in this class dataset, the Kozich et al.(2013) AEM
      # Link to paper: https://doi.org/10.1128/AEM.01043-13
# Therefore, we do not need to trim the primers, because they were not sequenced
filtered_reads <- 
  filterAndTrim(fwd = forward_reads, filt = filtered_forward_reads,
              rev = reverse_reads, filt.rev = filtered_reverse_reads,
              maxN = 0, maxEE = c(2,2), 
              trimLeft = 5,
              truncLen = c(250, 248),
              truncQ = 2, rm.phix = TRUE, compress = TRUE, multithread = TRUE)

##### Another example of a filterAndTrim Step 
# This dataset is from sequences generated by Cornell Sequencing Facility using  
# the typical Earth Microbiome protocol mentioned in their 16S SOP:
        # https://earthmicrobiome.org/protocols-and-standards/16s/
# Here, the library prep was the standard Illumina 2-step PCR preparation and following
# In this example, the primer sequences ARE in the sequences and must be trimmed using trimLeft
#
#filterAndTrim(forward_reads, filtered_forward_reads,
#              reverse_reads, filtered_reverse_reads,
#              truncLen = c(240,220), trimLeft = c(19,20),
#              maxN = 0, maxEE = c(1,1), truncQ = 2, 
#              rm.phix = TRUE, compress = TRUE, 
#              multithread = TRUE)
```

# Assess Trimmed Read Quality 

```{r filterTrim-quality-plots,  fig.width=12, fig.height=8}
# Plot the 12 random samples after QC
forward_filteredQual_plot_12 <- 
  plotQualityProfile(filtered_forward_reads[random_samples]) + 
  labs(title = "Trimmed Forward Read Quality")

reverse_filteredQual_plot_12 <- 
  plotQualityProfile(filtered_reverse_reads[random_samples]) + 
  labs(title = "Trimmed Reverse Read Quality")

# Put the two plots together 
forward_filteredQual_plot_12 + reverse_filteredQual_plot_12
```

## Aggregated Trimmed Plots 
```{r qc-aggregate-plot, fig.width=5.5, fig.height=3.5}
# Aggregate all QC plots 
# Forward reads
forward_postQC_plot <- 
  plotQualityProfile(filtered_forward_reads, aggregate = TRUE) + 
  labs(title = "Forward Post-QC")

# reverse reads
reverse_postQC_plot <- 
  plotQualityProfile(filtered_reverse_reads, aggregate = TRUE) + 
  labs(title = "Reverse Post-QC")

postQC_aggregate_plot <- 
  # Plot the forward and reverse together 
  forward_postQC_plot + reverse_postQC_plot

# Show the plot
postQC_aggregate_plot
```

[Insert some interpretation regarding the quality of the raw QC plots]

Here, we see the sequences are improved from before. The very low quality that we saw in the pre-QC plots is mostly gone. If we wanted, we could trim more of the forward sequence. However, the quality here is above a phred score of 30, which I feel ok with. 


## Stats on read output from `filterAndTrim`

```{r filterTrim-stats}
# Make output into dataframe 
filtered_df <- as.data.frame(filtered_reads)
head(filtered_df)

# calculate some stats 
filtered_df %>%
  reframe(median_reads_in = median(reads.in),
          median_reads_out = median(reads.out),
          median_percent_retained = (median(reads.out)/median(reads.in)))
```

[Insert paragraph interpreting the results above]

- How many reads got through? Is it "enough"?
- Should you play with the paratmeters in `filterAndTrim()` more?  If so, which parameters? 


### Visualize QC differences in plot 
```{r pre-post-QC-plot, fig.width=6, fig.height=5.5}
# Plot the pre and post together in one plot
preQC_aggregate_plot / postQC_aggregate_plot
```

Here we can see how many total reads were removed from the QC (comparing the red numbers in the bottom of each plot.) We'd like to see the QC get better. 


# Check Render Time
```{r stop-time}
# Take the time now that we are at the end of the script
end_time <- Sys.time()
end_time 

# Echo the elapsed time
elapsed_time <- round((end_time - start_time), 3)
elapsed_time
```


# Session Information 
```{r session-info}
# Ensure reproducibility 
devtools::session_info()
```
